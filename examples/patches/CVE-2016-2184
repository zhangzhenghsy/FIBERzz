diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index fb62bce..6178bb5 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -150,6 +150,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
        usb_audio_err(chip, "cannot memdup\n");
        return -ENOMEM;
    }
+   INIT_LIST_HEAD(&fp->list);
    if (fp->nr_rates > MAX_NR_RATES) {
        kfree(fp);
        return -EINVAL;
@@ -193,6 +194,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
    return 0;
 
  error:
+   list_del(&fp->list); /* unlink for avoiding double-free */
    kfree(fp);
    kfree(rate_table);
    return err;
@@ -469,6 +471,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
    fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
    fp->datainterval = 0;
    fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+   INIT_LIST_HEAD(&fp->list);
 
    switch (fp->maxpacksize) {
    case 0x120:
@@ -492,6 +495,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
        ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
    err = snd_usb_add_audio_stream(chip, stream, fp);
    if (err < 0) {
+       list_del(&fp->list); /* unlink for avoiding double-free */
        kfree(fp);
        return err;
    }
diff --git a/sound/usb/stream.c b/sound/usb/stream.c
index c4dc577..8e9548bc 100644
--- a/sound/usb/stream.c
+++ b/sound/usb/stream.c
@@ -314,7 +314,9 @@ static struct snd_pcm_chmap_elem *convert_chmap(int channels, unsigned int bits,
 /*
  * add this endpoint to the chip instance.
  * if a stream with the same endpoint already exists, append to it.
- * if not, create a new pcm stream.
+ * if not, create a new pcm stream. note, fp is added to the substream
+ * fmt_list and will be freed on the chip instance release. do not free
+ * fp or do remove it from the substream fmt_list to avoid double-free.
  */
 int snd_usb_add_audio_stream(struct snd_usb_audio *chip,
                 int stream,
@@ -675,6 +677,7 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
                    * (fp->maxpacksize & 0x7ff);
        fp->attributes = parse_uac_endpoint_attributes(chip, alts, protocol, iface_no);
        fp->clock = clock;
+       INIT_LIST_HEAD(&fp->list);
 
        /* some quirks for attributes here */
 
@@ -723,6 +726,7 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
        dev_dbg(&dev->dev, "%u:%d: add audio endpoint %#x\n", iface_no, altno, fp->endpoint);
        err = snd_usb_add_audio_stream(chip, stream, fp);
        if (err < 0) {
+           list_del(&fp->list); /* unlink for avoiding double-free */
            kfree(fp->rate_table);
            kfree(fp->chmap);
            kfree(fp);
